<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deadlock Detection & Prediction System</title>
    <meta name="description" content="AI-Powered Deadlock Detection using Banker's Algorithm, Wait-For Graph, and Heuristic Prediction">
    <style>
        /* ============================================
           CSS STYLES - Neon Cyber Theme
           ============================================ */
       
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Colors */
            --bg-primary: #0A0D14;
            --bg-secondary: #12151C;
            --bg-card: #161A23;
            --border-color: #2A3142;
           
            --text-primary: #E8ECF4;
            --text-secondary: #8A94A6;
            --text-muted: #5A6478;
           
            --neon-blue: #00E0FF;
            --neon-purple: #A050FF;
            --neon-green: #00FF88;
            --neon-amber: #FFB347;
            --neon-red: #FF004D;
           
            /* Fonts */
            --font-heading: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-body: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-mono: 'Courier New', Courier, monospace;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Navigation */
        .navbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
        }

        .nav-links button {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            transition: all 0.3s;
            font-size: 0.95rem;
        }

        .nav-links button:hover,
        .nav-links button.active {
            color: var(--neon-blue);
            background: rgba(0, 224, 255, 0.1);
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .card-header {
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.25rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .card-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            gap: 1.5rem;
        }

        .grid-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-3 { grid-template-columns: repeat(3, 1fr); }
        .grid-4 { grid-template-columns: repeat(4, 1fr); }

        @media (max-width: 768px) {
            .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; }
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--neon-blue);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            box-shadow: 0 0 20px var(--neon-blue);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
        }

        .btn-danger {
            background: var(--neon-red);
            color: white;
        }

        .btn-success {
            background: var(--neon-green);
            color: var(--bg-primary);
        }

        /* Input Fields */
        input[type="number"],
        input[type="text"],
        select {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            color: var(--text-primary);
            font-family: var(--font-mono);
            width: 100%;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 224, 255, 0.2);
        }

        /* Matrix Table */
        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-family: var(--font-mono);
        }

        .matrix-table th,
        .matrix-table td {
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            text-align: center;
        }

        .matrix-table th {
            background: var(--bg-secondary);
            color: var(--neon-blue);
            font-weight: 600;
        }

        .matrix-table input {
            width: 60px;
            text-align: center;
        }

        /* Gauge Component */
        .gauge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }

        .gauge-svg {
            filter: drop-shadow(0 0 10px currentColor);
        }

        .gauge-value {
            font-family: var(--font-mono);
            font-weight: bold;
            font-size: 2rem;
        }

        .gauge-label {
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .risk-low { color: var(--neon-green); }
        .risk-medium { color: var(--neon-amber); }
        .risk-high { color: var(--neon-purple); }
        .risk-critical { color: var(--neon-red); }

        /* Wait-For Graph */
        .graph-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1rem;
            position: relative;
            min-height: 400px;
        }

        .graph-legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1.5rem;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Status Badges */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .badge-success {
            background: rgba(0, 255, 136, 0.1);
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
        }

        .badge-danger {
            background: rgba(255, 0, 77, 0.1);
            color: var(--neon-red);
            border: 1px solid var(--neon-red);
        }

        .badge-warning {
            background: rgba(255, 179, 71, 0.1);
            color: var(--neon-amber);
            border: 1px solid var(--neon-amber);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            color: var(--text-primary);
        }

        .tab-btn.active {
            background: var(--bg-card);
            color: var(--neon-blue);
            border-bottom: 2px solid var(--neon-blue);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Progress Bar */
        .progress-bar {
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        /* Presets */
        .preset-card {
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-card:hover {
            border-color: var(--neon-blue);
            transform: translateY(-2px);
        }

        .preset-card.selected {
            border-color: var(--neon-blue);
            background: rgba(0, 224, 255, 0.1);
        }

        /* Recommendation Cards */
        .recommendation {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .recommendation-method {
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 20px currentColor); }
        }

        .animate-pulse {
            animation: pulse 2s infinite;
        }

        .animate-glow {
            animation: glow 2s infinite;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--neon-blue);
        }

        /* Page sections */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .hero {
            text-align: center;
            padding: 4rem 2rem;
        }

        .hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            color: var(--text-secondary);
            font-size: 1.2rem;
            max-width: 600px;
            margin: 0 auto 2rem;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 3rem;
        }

        .feature-card {
            text-align: center;
            padding: 2rem;
        }

        .feature-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            text-align: center;
            padding: 1rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            font-family: var(--font-mono);
            color: var(--neon-blue);
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Explanation boxes */
        .explanation {
            background: var(--bg-secondary);
            border-left: 3px solid var(--neon-blue);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        /* Status cards */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .status-card {
            text-align: center;
            padding: 1.5rem;
            border-radius: 12px;
        }

        .status-card.success { background: rgba(0, 255, 136, 0.1); border: 1px solid var(--neon-green); }
        .status-card.danger { background: rgba(255, 0, 77, 0.1); border: 1px solid var(--neon-red); }
        .status-card.warning { background: rgba(255, 179, 71, 0.1); border: 1px solid var(--neon-amber); }
        .status-card.info { background: rgba(0, 224, 255, 0.1); border: 1px solid var(--neon-blue); }

        .sequence-box {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .sequence-item {
            background: var(--bg-secondary);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-family: var(--font-mono);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
        }

        .sequence-arrow {
            color: var(--text-muted);
        }

        .cycle-box {
            background: rgba(255, 0, 77, 0.1);
            border: 1px solid var(--neon-red);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-family: var(--font-mono);
            color: var(--neon-red);
            margin-bottom: 0.5rem;
        }

        /* Flex utilities */
        .flex { display: flex; }
        .flex-wrap { flex-wrap: wrap; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-1 { gap: 0.5rem; }
        .gap-2 { gap: 1rem; }
        .gap-3 { gap: 1.5rem; }
        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .mb-3 { margin-bottom: 1.5rem; }
        .mt-2 { margin-top: 1rem; }
        .mt-3 { margin-top: 1.5rem; }
        .text-center { text-align: center; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="logo">‚ö° Deadlock.AI</div>
        <div class="nav-links">
            <button class="active" onclick="showPage('home')">Home</button>
            <button onclick="showPage('scenario')">Scenario</button>
            <button onclick="showPage('prediction')">Prediction</button>
            <button onclick="showPage('detection')">Detection</button>
            <button onclick="showPage('resolution')">Resolution</button>
            <button onclick="showPage('about')">About</button>
        </div>
    </nav>

    <div class="container">
        <!-- HOME PAGE -->
        <div id="page-home" class="page active">
            <div class="hero">
                <h1>Deadlock Detection & Prediction</h1>
                <p>Advanced system analysis using Banker's Algorithm, Wait-For Graph visualization, and heuristic-based risk prediction.</p>
                <div class="flex gap-2 justify-center">
                    <button class="btn btn-primary" onclick="showPage('scenario')">
                        üöÄ Try Live Demo
                    </button>
                    <button class="btn btn-secondary" onclick="showPage('about')">
                        üìñ Learn More
                    </button>
                </div>
            </div>

            <div class="feature-grid">
                <div class="card feature-card">
                    <div class="feature-icon" style="color: var(--neon-amber);">üìä</div>
                    <h3 class="card-title">Prediction</h3>
                    <p class="card-description">Heuristic-based risk assessment with probability scoring and unsafe chain detection.</p>
                </div>
                <div class="card feature-card">
                    <div class="feature-icon" style="color: var(--neon-red);">üîç</div>
                    <h3 class="card-title">Detection</h3>
                    <p class="card-description">Wait-For Graph analysis with DFS cycle detection and Banker's Algorithm safety check.</p>
                </div>
                <div class="card feature-card">
                    <div class="feature-icon" style="color: var(--neon-green);">üõ†Ô∏è</div>
                    <h3 class="card-title">Resolution</h3>
                    <p class="card-description">Intelligent recommendations for breaking deadlocks with impact analysis.</p>
                </div>
            </div>
        </div>

        <!-- SCENARIO PAGE -->
        <div id="page-scenario" class="page">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìù System Configuration</h2>
                    <p class="card-description">Configure the number of processes and resources, then fill in the allocation and maximum demand matrices.</p>
                </div>

                <div class="grid grid-2 mb-3">
                    <div>
                        <label>Number of Processes (P)</label>
                        <input type="number" id="numProcesses" value="3" min="1" max="10" onchange="updateDimensions()">
                    </div>
                    <div>
                        <label>Number of Resources (R)</label>
                        <input type="number" id="numResources" value="3" min="1" max="10" onchange="updateDimensions()">
                    </div>
                </div>

                <div class="grid grid-2">
                    <!-- Allocation Matrix -->
                    <div class="card">
                        <h3 class="card-title mb-2">Allocation Matrix</h3>
                        <p class="card-description mb-2">Resources currently allocated to each process</p>
                        <div id="allocationMatrix"></div>
                    </div>

                    <!-- Maximum Matrix -->
                    <div class="card">
                        <h3 class="card-title mb-2">Maximum Demand Matrix</h3>
                        <p class="card-description mb-2">Maximum resources each process may request</p>
                        <div id="maxMatrix"></div>
                    </div>
                </div>

                <!-- Available Resources -->
                <div class="card mt-2">
                    <h3 class="card-title mb-2">Available Resources</h3>
                    <p class="card-description mb-2">Currently available resources in the system</p>
                    <div id="availableVector"></div>
                </div>

                <!-- Presets -->
                <div class="card mt-2">
                    <h3 class="card-title mb-2">Quick Presets</h3>
                    <div class="grid grid-4">
                        <div class="preset-card" onclick="loadPreset('safe')">
                            <div style="color: var(--neon-green);">‚úì Safe State</div>
                            <small>No deadlock risk</small>
                        </div>
                        <div class="preset-card" onclick="loadPreset('unsafe')">
                            <div style="color: var(--neon-amber);">‚ö† Unsafe State</div>
                            <small>Potential deadlock</small>
                        </div>
                        <div class="preset-card" onclick="loadPreset('deadlock')">
                            <div style="color: var(--neon-red);">‚úï Deadlock</div>
                            <small>Active deadlock</small>
                        </div>
                        <div class="preset-card" onclick="loadPreset('highContention')">
                            <div style="color: var(--neon-purple);">üî• High Contention</div>
                            <small>Resource competition</small>
                        </div>
                    </div>
                </div>

                <div class="flex gap-2 mt-3">
                    <button class="btn btn-primary" onclick="runAnalysis()">
                        ‚ñ∂ Run Analysis
                    </button>
                    <button class="btn btn-secondary" onclick="resetScenario()">
                        ‚Ü∫ Reset
                    </button>
                </div>
            </div>
        </div>

        <!-- PREDICTION PAGE -->
        <div id="page-prediction" class="page">
            <div class="card">
                <div class="card-header flex justify-between items-center">
                    <div>
                        <h2 class="card-title">üìä Deadlock Prediction</h2>
                        <p class="card-description">Heuristic-based probability assessment</p>
                    </div>
                    <button class="btn btn-primary" onclick="runPrediction()">
                        ‚ñ∂ Run Prediction
                    </button>
                </div>

                <div id="predictionResults">
                    <div class="text-center" style="padding: 3rem; color: var(--text-muted);">
                        Click "Run Prediction" to analyze deadlock probability
                    </div>
                </div>
            </div>
        </div>

        <!-- DETECTION PAGE -->
        <div id="page-detection" class="page">
            <div class="card">
                <div class="card-header flex justify-between items-center">
                    <div>
                        <h2 class="card-title">üîç Deadlock Detection</h2>
                        <p class="card-description">Wait-For Graph analysis and cycle detection</p>
                    </div>
                    <button class="btn btn-primary" onclick="runDetection()">
                        ‚ñ∂ Run Detection
                    </button>
                </div>

                <div id="detectionResults">
                    <div class="text-center" style="padding: 3rem; color: var(--text-muted);">
                        Click "Run Detection" to analyze the system
                    </div>
                </div>
            </div>
        </div>

        <!-- RESOLUTION PAGE -->
        <div id="page-resolution" class="page">
            <div class="card">
                <div class="card-header flex justify-between items-center">
                    <div>
                        <h2 class="card-title">üõ†Ô∏è Resolution Strategies</h2>
                        <p class="card-description">Recommended actions to resolve deadlock</p>
                    </div>
                    <button class="btn btn-primary" onclick="runResolution()">
                        ‚ñ∂ Generate Suggestions
                    </button>
                </div>

                <div id="resolutionResults">
                    <div class="text-center" style="padding: 3rem; color: var(--text-muted);">
                        Click "Generate Suggestions" to get resolution recommendations
                    </div>
                </div>
            </div>
        </div>

        <!-- ABOUT PAGE -->
        <div id="page-about" class="page">
            <div class="card">
                <h2 class="card-title mb-3">üìö How It Works</h2>
               
                <div class="card mb-2">
                    <h3 style="color: var(--neon-blue);">1. Banker's Algorithm</h3>
                    <p class="mt-2">The Banker's Algorithm determines if a system is in a safe state by simulating resource allocation. It checks if there exists a sequence of process completions where each process can obtain its required resources.</p>
                    <div class="explanation mt-2">
                        <strong>Key Concept:</strong> Need Matrix = Maximum - Allocation<br>
                        A state is <em>safe</em> if a safe sequence exists where all processes can complete.
                    </div>
                </div>

                <div class="card mb-2">
                    <h3 style="color: var(--neon-purple);">2. Wait-For Graph (WFG)</h3>
                    <p class="mt-2">The Wait-For Graph is a directed graph where nodes represent processes and edges represent wait relationships. Process P<sub>i</sub> has an edge to P<sub>j</sub> if P<sub>i</sub> is waiting for a resource held by P<sub>j</sub>.</p>
                    <div class="explanation mt-2">
                        <strong>Cycle Detection:</strong> A cycle in the WFG indicates a deadlock. We use DFS (Depth-First Search) to detect cycles.
                    </div>
                </div>

                <div class="card mb-2">
                    <h3 style="color: var(--neon-amber);">3. Prediction Model</h3>
                    <p class="mt-2">The prediction model uses a weighted heuristic approach combining multiple risk factors:</p>
                    <ul class="mt-2" style="margin-left: 1.5rem;">
                        <li>Resource utilization percentage</li>
                        <li>Resources near exhaustion</li>
                        <li>Wait chain length in WFG</li>
                        <li>Multi-resource request patterns</li>
                        <li>Banker's algorithm safety state</li>
                        <li>Existing cycles</li>
                    </ul>
                </div>

                <div class="card">
                    <h3 style="color: var(--neon-green);">4. Resolution Strategies</h3>
                    <ul class="mt-2" style="margin-left: 1.5rem;">
                        <li><strong>Rollback:</strong> Revert a process to release resources</li>
                        <li><strong>Preempt:</strong> Force release of specific resources</li>
                        <li><strong>Priority Boost:</strong> Let near-complete processes finish first</li>
                        <li><strong>Throttle:</strong> Block new resource requests temporarily</li>
                        <li><strong>Kill:</strong> Terminate a process (last resort)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
 <!-- ============================================
         JAVASCRIPT - Core Algorithms & UI Logic
         ============================================ -->
    <script>
        // =============================================
        // GLOBAL STATE
        // =============================================
        let systemState = {
            processes: 3,
            resources: 3,
            allocation: [[0,1,0], [2,0,0], [3,0,2]],
            max: [[7,5,3], [3,2,2], [9,0,2]],
            available: [3,3,2]
        };

        let predictionResult = null;
        let detectionResult = null;
        let resolutionResult = null;

        // =============================================
        // PRESET SCENARIOS
        // =============================================
        const presetScenarios = {
            safe: {
                processes: 3,
                resources: 3,
                allocation: [[0,1,0], [2,0,0], [3,0,2]],
                max: [[7,5,3], [3,2,2], [9,0,2]],
                available: [3,3,2]
            },
            unsafe: {
                processes: 4,
                resources: 3,
                allocation: [[0,1,0], [2,0,0], [3,0,2], [2,1,1]],
                max: [[7,5,3], [3,2,2], [9,0,2], [4,2,2]],
                available: [0,1,0]
            },
            deadlock: {
                processes: 4,
                resources: 2,
                allocation: [[1,0], [0,1], [1,0], [0,1]],
                max: [[1,1], [1,1], [1,1], [1,1]],
                available: [0,0]
            },
            highContention: {
                processes: 5,
                resources: 3,
                allocation: [[2,0,1], [1,1,0], [1,0,2], [0,2,0], [1,1,1]],
                max: [[4,2,2], [3,3,1], [2,1,4], [2,4,1], [3,3,3]],
                available: [1,0,1]
            }
        };

        // =============================================
        // CORE ALGORITHMS
        // =============================================

        /**
         * Calculate Need Matrix (Max - Allocation)
         */
        function calculateNeedMatrix(allocation, max) {
            return max.map((row, i) =>
                row.map((val, j) => val - allocation[i][j])
            );
        }

        /**
         * Analyze system state
         */
        function analyzeScenario(state) {
            const { allocation, available, processes, resources } = state;
            const needMatrix = calculateNeedMatrix(allocation, state.max);
           
            // Calculate total allocated per resource
            const totalAllocated = Array(resources).fill(0);
            for (let i = 0; i < processes; i++) {
                for (let j = 0; j < resources; j++) {
                    totalAllocated[j] += allocation[i][j];
                }
            }
           
            // Calculate total resources
            const totalResources = available.map((avail, j) => avail + totalAllocated[j]);
           
            // Calculate utilization percentage
            const utilizationPercentage = totalResources.map((total, j) =>
                total > 0 ? (totalAllocated[j] / total) * 100 : 0
            );
           
            return {
                needMatrix,
                totalAllocated,
                totalResources,
                utilizationPercentage
            };
        }

        /**
         * Banker's Algorithm - Safety Check
         */
        function bankersSafetyCheck(state) {
            const { allocation, max, available, processes, resources } = state;
            const need = calculateNeedMatrix(allocation, max);
           
            const work = [...available];
            const finish = Array(processes).fill(false);
            const sequence = [];
           
            let found = true;
            while (found && sequence.length < processes) {
                found = false;
               
                for (let i = 0; i < processes; i++) {
                    if (!finish[i]) {
                        let canFinish = true;
                        for (let j = 0; j < resources; j++) {
                            if (need[i][j] > work[j]) {
                                canFinish = false;
                                break;
                            }
                        }
                       
                        if (canFinish) {
                            for (let j = 0; j < resources; j++) {
                                work[j] += allocation[i][j];
                            }
                            finish[i] = true;
                            sequence.push(i);
                            found = true;
                        }
                    }
                }
            }
           
            const allFinished = finish.every(f => f);
            return {
                safe: allFinished,
                sequence: allFinished ? sequence : null
            };
        }

        /**
         * Build Wait-For Graph
         */
        function buildWaitForGraph(state) {
            const { allocation, max, available, processes, resources } = state;
            const need = calculateNeedMatrix(allocation, max);
           
            const nodes = Array.from({ length: processes }, (_, i) => ({
                id: i,
                label: `P${i}`,
                inCycle: false
            }));
           
            const edges = [];
           
            for (let i = 0; i < processes; i++) {
                for (let j = 0; j < resources; j++) {
                    if (need[i][j] > 0 && available[j] < need[i][j]) {
                        for (let k = 0; k < processes; k++) {
                            if (k !== i && allocation[k][j] > 0) {
                                const edgeExists = edges.some(e => e.from === i && e.to === k);
                                if (!edgeExists) {
                                    edges.push({ from: i, to: k, resource: j });
                                }
                            }
                        }
                    }
                }
            }
           
            return { nodes, edges };
        }

        /**
         * DFS-based Cycle Detection
         */
        function detectCycles(graph) {
            const n = graph.nodes.length;
            const adj = Array.from({ length: n }, () => []);
           
            for (const edge of graph.edges) {
                adj[edge.from].push(edge.to);
            }
           
            const cycles = [];
            const visited = new Set();
            const recStack = new Set();
            const path = [];
           
            function dfs(node) {
                visited.add(node);
                recStack.add(node);
                path.push(node);
               
                for (const neighbor of adj[node]) {
                    if (!visited.has(neighbor)) {
                        dfs(neighbor);
                    } else if (recStack.has(neighbor)) {
                        const cycleStart = path.indexOf(neighbor);
                        if (cycleStart !== -1) {
                            const cycle = path.slice(cycleStart);
                            const cycleKey = [...cycle].sort().join(',');
                            const isUnique = !cycles.some(c => [...c].sort().join(',') === cycleKey);
                            if (isUnique && cycle.length > 1) {
                                cycles.push([...cycle]);
                            }
                        }
                    }
                }
               
                path.pop();
                recStack.delete(node);
            }
           
            for (let i = 0; i < n; i++) {
                if (!visited.has(i)) {
                    dfs(i);
                }
            }
           
            // Check for simple two-node cycles
            for (let i = 0; i < n; i++) {
                for (const j of adj[i]) {
                    if (adj[j] && adj[j].includes(i)) {
                        const cycle = [i, j];
                        const cycleKey = [...cycle].sort().join(',');
                        const isUnique = !cycles.some(c => [...c].sort().join(',') === cycleKey);
                        if (isUnique) {
                            cycles.push(cycle);
                        }
                    }
                }
            }
           
            return cycles;
        }

        /**
         * Detect Deadlock
         */
        function detectDeadlock(state) {
            const wfg = buildWaitForGraph(state);
            const cycles = detectCycles(wfg);
            const bankers = bankersSafetyCheck(state);
           
            // Mark nodes in cycles
            const nodesInCycles = new Set();
            cycles.forEach(cycle => cycle.forEach(node => nodesInCycles.add(node)));
            wfg.nodes.forEach(node => {
                node.inCycle = nodesInCycles.has(node.id);
            });
           
            const isDeadlocked = cycles.length > 0;
           
            let explanation = '';
            if (isDeadlocked) {
                explanation = `Deadlock detected! ${cycles.length} cycle(s) found. `;
                explanation += `Processes involved: ${[...nodesInCycles].map(p => `P${p}`).join(', ')}.`;
            } else if (!bankers.safe) {
                explanation = 'System is UNSAFE according to Banker\'s algorithm. No deadlock yet, but deadlock is possible.';
            } else {
                explanation = `System is SAFE. Safe sequence: ${bankers.sequence?.map(p => `P${p}`).join(' ‚Üí ') || 'N/A'}`;
            }
           
            return {
                isDeadlocked,
                isSafe: bankers.safe,
                cyclePaths: cycles,
                waitForGraph: wfg,
                safeSequence: bankers.sequence,
                explanation
            };
        }

        /**
         * Find longest path in WFG
         */
        function findLongestPath(graph) {
            const n = graph.nodes.length;
            const adj = Array.from({ length: n }, () => []);
           
            for (const edge of graph.edges) {
                adj[edge.from].push(edge.to);
            }
           
            let maxLength = 0;
            const visited = new Set();
           
            function dfs(node, length) {
                if (visited.has(node)) return length;
                visited.add(node);
               
                let max = length;
                for (const neighbor of adj[node]) {
                    max = Math.max(max, dfs(neighbor, length + 1));
                }
               
                visited.delete(node);
                return max;
            }
           
            for (let i = 0; i < n; i++) {
                maxLength = Math.max(maxLength, dfs(i, 1));
            }
           
            return maxLength;
        }

        /**
         * Predict Deadlock
         */
        function predictDeadlock(state) {
            const { allocation, max, available, processes, resources } = state;
            const analysis = analyzeScenario(state);
            const detection = detectDeadlock(state);
            const wfg = detection.waitForGraph;
           
            const features = [];
           
            // 1. Resource utilization
            const avgUtilization = analysis.utilizationPercentage.reduce((a, b) => a + b, 0) / resources;
            const utilizationRisk = Math.min(avgUtilization / 100, 1);
            features.push({
                feature: 'Resource Utilization',
                contribution: utilizationRisk * 25,
                description: `Average utilization is ${avgUtilization.toFixed(1)}%`
            });
           
            // 2. Resources near exhaustion
            let exhaustedCount = 0;
            for (let j = 0; j < resources; j++) {
                if (analysis.totalResources[j] > 0) {
                    const availablePercent = (available[j] / analysis.totalResources[j]) * 100;
                    if (availablePercent < 20) exhaustedCount++;
                }
            }
            const exhaustionRisk = exhaustedCount / resources;
            features.push({
                feature: 'Resource Exhaustion',
                contribution: exhaustionRisk * 20,
                description: `${exhaustedCount} of ${resources} resources near exhaustion`
            });
           
            // 3. Wait chain length
            const maxChainLength = findLongestPath(wfg);
            const chainRisk = Math.min(maxChainLength / processes, 1);
            features.push({
                feature: 'Wait Chain Length',
                contribution: chainRisk * 20,
                description: `Longest wait chain: ${maxChainLength} processes`
            });
           
            // 4. Multi-resource requests
            let multiResourceProcesses = 0;
            for (let i = 0; i < processes; i++) {
                let resourcesNeeded = 0;
                for (let j = 0; j < resources; j++) {
                    if (analysis.needMatrix[i][j] > 0) resourcesNeeded++;
                }
                if (resourcesNeeded > 1) multiResourceProcesses++;
            }
            const multiResourceRisk = multiResourceProcesses / processes;
            features.push({
                feature: 'Multi-Resource Requests',
                contribution: multiResourceRisk * 15,
                description: `${multiResourceProcesses} processes need multiple resources`
            });
           
            // 5. Safety state
            const safetyRisk = detection.isSafe ? 0 : 0.8;
            features.push({
                feature: 'Safety State',
                contribution: safetyRisk * 15,
                description: detection.isSafe ? 'System is safe' : 'System is UNSAFE!'
            });
           
            // 6. Existing cycles
            const cycleRisk = detection.isDeadlocked ? 1 : 0;
            features.push({
                feature: 'Existing Cycles',
                contribution: cycleRisk * 5,
                description: detection.isDeadlocked ? `${detection.cyclePaths.length} cycle(s) found!` : 'No cycles'
            });
           
            // Calculate probability
            let probability = features.reduce((sum, f) => sum + f.contribution, 0);
           
            if (detection.isDeadlocked) {
                probability = Math.max(probability, 95);
            } else if (!detection.isSafe) {
                probability = Math.max(probability, 60);
            }
           
            probability = Math.min(probability, 100);
           
            // Risk label
            let riskLabel;
            if (probability < 25) riskLabel = 'Low';
            else if (probability < 50) riskLabel = 'Medium';
            else if (probability < 75) riskLabel = 'High';
            else riskLabel = 'Critical';
           
            // Summary
            let summary;
            if (detection.isDeadlocked) {
                summary = `CRITICAL: Active deadlock with ${detection.cyclePaths.length} cycle(s). Immediate action required.`;
            } else if (riskLabel === 'Critical') {
                summary = 'System at critical risk. Resource exhaustion and long wait chains detected.';
            } else if (riskLabel === 'High') {
                summary = 'High risk. System unsafe with resource competition.';
            } else if (riskLabel === 'Medium') {
                summary = 'Moderate risk. Some contention but recovery possible.';
            } else {
                summary = 'Low risk. System has adequate resources.';
            }
           
            return {
                probability,
                riskLabel,
                explainability: features,
                summary
            };
        }

        /**
         * Suggest Resolution Strategies
         */
        function suggestResolution(state, detection) {
            const recommendations = [];
            const { allocation, max, processes, resources } = state;
            const need = calculateNeedMatrix(allocation, max);
           
            if (!detection.isDeadlocked && detection.isSafe) {
                return { recommendations: [], best: null };
            }
           
            // Get problematic processes
            const problematicProcesses = new Set();
            detection.cyclePaths.forEach(cycle => cycle.forEach(p => problematicProcesses.add(p)));
           
            if (problematicProcesses.size === 0) {
                detection.waitForGraph.edges.forEach(edge => {
                    problematicProcesses.add(edge.to);
                });
            }
           
            if (problematicProcesses.size === 0) {
                for (let i = 0; i < processes; i++) {
                    if (allocation[i].some(a => a > 0)) {
                        problematicProcesses.add(i);
                    }
                }
            }
           
            for (const proc of problematicProcesses) {
                const procAllocation = allocation[proc].reduce((a, b) => a + b, 0);
                const procNeed = need[proc].reduce((a, b) => a + b, 0);
               
                // Rollback
                if (procAllocation > 0) {
                    recommendations.push({
                        method: 'rollback',
                        targetProcess: proc,
                        explanation: `Roll back P${proc} to release ${procAllocation} resource units.`,
                        estimatedCost: procAllocation * 10,
                        workLost: procAllocation,
                        processesAffected: 1,
                        impact: procAllocation > 5 ? 'High' : procAllocation > 2 ? 'Medium' : 'Low'
                    });
                }
               
                // Preempt
                for (let r = 0; r < resources; r++) {
                    if (allocation[proc][r] > 0) {
                        recommendations.push({
                            method: 'preempt',
                            targetProcess: proc,
                            explanation: `Preempt R${r} (${allocation[proc][r]} units) from P${proc}.`,
                            estimatedCost: allocation[proc][r] * 5,
                            workLost: allocation[proc][r],
                            processesAffected: 1,
                            impact: allocation[proc][r] > 3 ? 'Medium' : 'Low'
                        });
                        break;
                    }
                }
               
                // Priority boost
                if (procNeed < procAllocation) {
                    recommendations.push({
                        method: 'priority-boost',
                        targetProcess: proc,
                        explanation: `Boost P${proc} priority (needs only ${procNeed} more units).`,
                        estimatedCost: 2,
                        workLost: 0,
                        processesAffected: processes,
                        impact: 'Low'
                    });
                }
            }
           
            // Throttle
            recommendations.push({
                method: 'throttle',
                targetProcess: -1,
                explanation: 'Temporarily block new resource requests.',
                estimatedCost: 15,
                workLost: 0,
                processesAffected: processes,
                impact: 'Medium'
            });
           
            // Kill
            if (detection.isDeadlocked && problematicProcesses.size > 0) {
                let maxResources = 0;
                let killTarget = 0;
                for (const proc of problematicProcesses) {
                    const total = allocation[proc].reduce((a, b) => a + b, 0);
                    if (total > maxResources) {
                        maxResources = total;
                        killTarget = proc;
                    }
                }
               
                recommendations.push({
                    method: 'kill',
                    targetProcess: killTarget,
                    explanation: `Terminate P${killTarget} to release ${maxResources} resource units.`,
                    estimatedCost: maxResources * 20,
                    workLost: maxResources,
                    processesAffected: 1,
                    impact: 'High'
                });
            }
           
            recommendations.sort((a, b) => a.estimatedCost - b.estimatedCost);
           
            return {
                recommendations,
                best: recommendations[0] || null
            };
        }

        /**
         * Apply Resolution
         */
        function applyResolution(state, resolution) {
            const newState = {
                ...state,
                allocation: state.allocation.map(row => [...row]),
                max: state.max.map(row => [...row]),
                available: [...state.available]
            };
           
            const proc = resolution.targetProcess;
           
            switch (resolution.method) {
                case 'rollback':
                case 'kill':
                    if (proc >= 0) {
                        for (let j = 0; j < state.resources; j++) {
                            newState.available[j] += newState.allocation[proc][j];
                            newState.allocation[proc][j] = 0;
                        }
                        if (resolution.method === 'kill') {
                            for (let j = 0; j < state.resources; j++) {
                                newState.max[proc][j] = 0;
                            }
                        }
                    }
                    break;
                   
                case 'preempt':
                    if (proc >= 0) {
                        for (let j = 0; j < state.resources; j++) {
                            if (newState.allocation[proc][j] > 0) {
                                newState.available[j] += newState.allocation[proc][j];
                                newState.allocation[proc][j] = 0;
                                break;
                            }
                        }
                    }
                    break;
                   
                case 'priority-boost':
                    if (proc >= 0) {
                        for (let j = 0; j < state.resources; j++) {
                            newState.available[j] += newState.allocation[proc][j];
                            newState.allocation[proc][j] = 0;
                            newState.max[proc][j] = 0;
                        }
                    }
                    break;
                   
                case 'throttle':
                    for (let i = 0; i < state.processes; i++) {
                        for (let j = 0; j < state.resources; j++) {
                            if (newState.max[i][j] > newState.allocation[i][j] + 1) {
                                newState.max[i][j] = newState.allocation[i][j] + 1;
                            }
                        }
                    }
                    break;
            }
           
            return newState;
        }

        // =============================================
        // UI FUNCTIONS
        // =============================================

        function showPage(pageId) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            // Show selected page
            document.getElementById(`page-${pageId}`).classList.add('active');
            // Update nav
            document.querySelectorAll('.nav-links button').forEach(b => b.classList.remove('active'));
            document.querySelector(`.nav-links button[onclick="showPage('${pageId}')"]`).classList.add('active');
        }

        function updateDimensions() {
            const p = parseInt(document.getElementById('numProcesses').value);
            const r = parseInt(document.getElementById('numResources').value);
           
            systemState.processes = p;
            systemState.resources = r;
           
            // Resize matrices
            systemState.allocation = Array.from({ length: p }, (_, i) =>
                Array.from({ length: r }, (_, j) => systemState.allocation[i]?.[j] || 0)
            );
            systemState.max = Array.from({ length: p }, (_, i) =>
                Array.from({ length: r }, (_, j) => systemState.max[i]?.[j] || 0)
            );
            systemState.available = Array.from({ length: r }, (_, j) =>
                systemState.available[j] || 0
            );
           
            renderMatrices();
        }

        function renderMatrices() {
            const { processes, resources, allocation, max, available } = systemState;
           
            // Allocation Matrix
            let allocationHTML = '<table class="matrix-table"><tr><th></th>';
            for (let j = 0; j < resources; j++) allocationHTML += `<th>R${j}</th>`;
            allocationHTML += '</tr>';
            for (let i = 0; i < processes; i++) {
                allocationHTML += `<tr><th>P${i}</th>`;
                for (let j = 0; j < resources; j++) {
                    allocationHTML += `<td><input type="number" min="0" value="${allocation[i][j]}" onchange="updateAllocation(${i},${j},this.value)"></td>`;
                }
                allocationHTML += '</tr>';
            }
            allocationHTML += '</table>';
            document.getElementById('allocationMatrix').innerHTML = allocationHTML;
           
            // Max Matrix
            let maxHTML = '<table class="matrix-table"><tr><th></th>';
            for (let j = 0; j < resources; j++) maxHTML += `<th>R${j}</th>`;
            maxHTML += '</tr>';
            for (let i = 0; i < processes; i++) {
                maxHTML += `<tr><th>P${i}</th>`;
                for (let j = 0; j < resources; j++) {
                    maxHTML += `<td><input type="number" min="0" value="${max[i][j]}" onchange="updateMax(${i},${j},this.value)"></td>`;
                }
                maxHTML += '</tr>';
            }
            maxHTML += '</table>';
            document.getElementById('maxMatrix').innerHTML = maxHTML;
           
            // Available Vector
            let availHTML = '<table class="matrix-table"><tr>';
            for (let j = 0; j < resources; j++) availHTML += `<th>R${j}</th>`;
            availHTML += '</tr><tr>';
            for (let j = 0; j < resources; j++) {
                availHTML += `<td><input type="number" min="0" value="${available[j]}" onchange="updateAvailable(${j},this.value)"></td>`;
            }
            availHTML += '</tr></table>';
            document.getElementById('availableVector').innerHTML = availHTML;
        }

        function updateAllocation(i, j, val) {
            systemState.allocation[i][j] = parseInt(val) || 0;
        }

        function updateMax(i, j, val) {
            systemState.max[i][j] = parseInt(val) || 0;
        }

        function updateAvailable(j, val) {
            systemState.available[j] = parseInt(val) || 0;
        }

        function loadPreset(key) {
            const preset = presetScenarios[key];
            systemState = JSON.parse(JSON.stringify(preset));
            document.getElementById('numProcesses').value = preset.processes;
            document.getElementById('numResources').value = preset.resources;
            renderMatrices();
           
            // Clear results
            predictionResult = null;
            detectionResult = null;
            resolutionResult = null;
        }

        function resetScenario() {
            loadPreset('safe');
        }

        function runAnalysis() {
            runPrediction();
            runDetection();
            runResolution();
            showPage('prediction');
        }

        function runPrediction() {
            predictionResult = predictDeadlock(systemState);
            renderPrediction();
        }

        function runDetection() {
            detectionResult = detectDeadlock(systemState);
            renderDetection();
        }

        function runResolution() {
            if (!detectionResult) {
                detectionResult = detectDeadlock(systemState);
            }
            resolutionResult = suggestResolution(systemState, detectionResult);
            renderResolution();
        }

        function renderPrediction() {
            if (!predictionResult) {
                document.getElementById('predictionResults').innerHTML = '<div class="text-center" style="padding:3rem;color:var(--text-muted);">Click "Run Prediction" to analyze</div>';
                return;
            }
           
            const { probability, riskLabel, explainability, summary } = predictionResult;
            const riskClass = riskLabel.toLowerCase();
           
            let html = `
                <div class="grid grid-2 gap-3">
                    <div class="card">
                        <div class="gauge-container">
                            ${renderGauge(probability, riskLabel)}
                        </div>
                    </div>
                    <div class="card">
                        <h3 class="card-title">Summary</h3>
                        <p class="explanation">${summary}</p>
                       
                        <h4 class="mt-3 mb-2">Risk Factors</h4>
                        ${explainability.map(f => `
                            <div class="mb-2">
                                <div class="flex justify-between mb-1">
                                    <span>${f.feature}</span>
                                    <span style="color:var(--neon-blue);">${f.contribution.toFixed(1)}%</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width:${f.contribution}%;background:var(--neon-blue);"></div>
                                </div>
                                <small style="color:var(--text-muted);">${f.description}</small>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="flex gap-2 mt-3">
                    <button class="btn btn-primary" onclick="showPage('detection')">Continue to Detection ‚Üí</button>
                </div>
            `;
           
            document.getElementById('predictionResults').innerHTML = html;
        }

        function renderGauge(value, riskLevel) {
            const width = 200;
            const height = 120;
            const strokeWidth = 12;
            const radius = (width - strokeWidth) / 2;
            const circumference = Math.PI * radius;
            const offset = circumference * (1 - value / 100);
           
            let color;
            if (value < 25) color = 'var(--neon-green)';
            else if (value < 50) color = 'var(--neon-amber)';
            else if (value < 75) color = 'var(--neon-purple)';
            else color = 'var(--neon-red)';
           
            return `
                <svg width="${width}" height="${height + 30}" viewBox="0 0 ${width} ${height + 10}">
                    <!-- Background arc -->
                    <path
                        d="M ${strokeWidth/2} ${height} A ${radius} ${radius} 0 0 1 ${width - strokeWidth/2} ${height}"
                        fill="none"
                        stroke="var(--border-color)"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                    />
                    <!-- Value arc -->
                    <path
                        d="M ${strokeWidth/2} ${height} A ${radius} ${radius} 0 0 1 ${width - strokeWidth/2} ${height}"
                        fill="none"
                        stroke="${color}"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                        stroke-dasharray="${circumference}"
                        stroke-dashoffset="${offset}"
                        style="filter: drop-shadow(0 0 8px ${color});"
                    />
                    <!-- Value text -->
                    <text x="${width/2}" y="${height - 10}" text-anchor="middle" fill="${color}" font-family="var(--font-mono)" font-size="28" font-weight="bold">
                        ${value.toFixed(0)}%
                    </text>
                </svg>
                <div class="gauge-label">Deadlock Probability</div>
                <div class="risk-${riskLevel.toLowerCase()}" style="font-weight:bold;font-size:1.2rem;">${riskLevel}</div>
            `;
        }

        function renderDetection() {
            if (!detectionResult) {
                document.getElementById('detectionResults').innerHTML = '<div class="text-center" style="padding:3rem;color:var(--text-muted);">Click "Run Detection" to analyze</div>';
                return;
            }
           
            const { isDeadlocked, isSafe, cyclePaths, waitForGraph, safeSequence, explanation } = detectionResult;
           
            let html = `
                <!-- Status Cards -->
                <div class="status-grid">
                    <div class="status-card ${isDeadlocked ? 'danger' : 'success'}">
                        <div style="font-size:2rem;">${isDeadlocked ? 'üî¥' : 'üü¢'}</div>
                        <div style="font-weight:bold;">${isDeadlocked ? 'DEADLOCK' : 'NO DEADLOCK'}</div>
                    </div>
                    <div class="status-card ${isSafe ? 'success' : 'warning'}">
                        <div style="font-size:2rem;">${isSafe ? '‚úì' : '‚ö†'}</div>
                        <div style="font-weight:bold;">${isSafe ? 'SAFE' : 'UNSAFE'}</div>
                    </div>
                    <div class="status-card info">
                        <div style="font-size:2rem;">${cyclePaths.length}</div>
                        <div style="font-weight:bold;">CYCLES</div>
                    </div>
                </div>
               
                <!-- Wait-For Graph -->
                <div class="card">
                    <h3 class="card-title mb-2">Wait-For Graph</h3>
                    <div class="graph-container">
                        ${renderWaitForGraph(waitForGraph, cyclePaths)}
                        <div class="graph-legend">
                            <div class="legend-item">
                                <div class="legend-dot" style="background:var(--neon-blue);"></div>
                                <span>Process</span>
                            </div>
                            <div class="legend-item">
                                <div style="width:20px;height:2px;background:var(--neon-blue);"></div>
                                <span>Waits for</span>
                            </div>
                            ${cyclePaths.length > 0 ? `
                                <div class="legend-item">
                                    <div class="legend-dot animate-pulse" style="background:var(--neon-red);"></div>
                                    <span style="color:var(--neon-red);">In Cycle</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
               
                <!-- Results -->
                <div class="grid grid-2 mt-2">
                    ${isSafe && safeSequence ? `
                        <div class="card">
                            <h3 class="card-title" style="color:var(--neon-green);">‚úì Safe Sequence</h3>
                            <div class="sequence-box mt-2">
                                ${safeSequence.map((p, i) => `
                                    <span class="sequence-item">P${p}</span>
                                    ${i < safeSequence.length - 1 ? '<span class="sequence-arrow">‚Üí</span>' : ''}
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                   
                    ${cyclePaths.length > 0 ? `
                        <div class="card">
                            <h3 class="card-title" style="color:var(--neon-red);">‚úï Detected Cycles</h3>
                            ${cyclePaths.map((cycle, i) => `
                                <div class="cycle-box mt-2">
                                    Cycle ${i + 1}: ${cycle.map(p => `P${p}`).join(' ‚Üí ')} ‚Üí P${cycle[0]}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
               
                <!-- Explanation -->
                <div class="explanation mt-2">
                    <strong>Analysis:</strong> ${explanation}
                </div>
               
                <div class="flex gap-2 mt-3">
                    <button class="btn btn-primary" onclick="showPage('resolution')">Continue to Resolution ‚Üí</button>
                </div>
            `;
           
            document.getElementById('detectionResults').innerHTML = html;
        }

        function renderWaitForGraph(graph, cyclePaths) {
            const width = 500;
            const height = 350;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 130;
           
            if (graph.nodes.length === 0) {
                return '<p style="text-align:center;color:var(--text-muted);padding:3rem;">No processes</p>';
            }
           
            // Calculate positions
            const positions = {};
            graph.nodes.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / graph.nodes.length - Math.PI / 2;
                positions[node.id] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
           
            // Check if edge is in cycle
            function isEdgeInCycle(from, to) {
                return cyclePaths.some(cycle => {
                    for (let i = 0; i < cycle.length; i++) {
                        const next = (i + 1) % cycle.length;
                        if (cycle[i] === from && cycle[next] === to) return true;
                    }
                    return false;
                });
            }
           
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}">`;
           
            // Arrow markers
            svg += `
                <defs>
                    <marker id="arrow-normal" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <path d="M0,0 L0,6 L9,3 z" fill="var(--neon-blue)" />
                    </marker>
                    <marker id="arrow-cycle" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <path d="M0,0 L0,6 L9,3 z" fill="var(--neon-red)" />
                    </marker>
                </defs>
            `;
           
            // Edges
            graph.edges.forEach(edge => {
                const from = positions[edge.from];
                const to = positions[edge.to];
                if (!from || !to) return;
               
                const inCycle = isEdgeInCycle(edge.from, edge.to);
                const color = inCycle ? 'var(--neon-red)' : 'var(--neon-blue)';
                const marker = inCycle ? 'url(#arrow-cycle)' : 'url(#arrow-normal)';
               
                // Calculate direction
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const nodeRadius = 24;
               
                const startX = from.x + (nodeRadius * dx) / dist;
                const startY = from.y + (nodeRadius * dy) / dist;
                const endX = to.x - (nodeRadius * dx) / dist;
                const endY = to.y - (nodeRadius * dy) / dist;
               
                // Curved path
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                const offset = dist * 0.15;
                const perpX = -(endY - startY) / dist * offset;
                const perpY = (endX - startX) / dist * offset;
               
                svg += `<path d="M ${startX} ${startY} Q ${midX + perpX} ${midY + perpY} ${endX} ${endY}"
                         fill="none" stroke="${color}" stroke-width="${inCycle ? 3 : 2}"
                         marker-end="${marker}" ${inCycle ? 'class="animate-pulse"' : ''}/>`;
               
                // Resource label
                if (edge.resource !== undefined) {
                    svg += `<text x="${midX + perpX + 10}" y="${midY + perpY - 5}"
                             fill="var(--text-muted)" font-size="10" font-family="var(--font-mono)">R${edge.resource}</text>`;
                }
            });
           
            // Nodes
            graph.nodes.forEach(node => {
                const pos = positions[node.id];
                const inCycle = node.inCycle;
                const color = inCycle ? 'var(--neon-red)' : 'var(--neon-blue)';
               
                svg += `<g transform="translate(${pos.x}, ${pos.y})" ${inCycle ? 'class="animate-pulse"' : ''}>`;
                svg += `<circle r="32" fill="${inCycle ? 'rgba(255,0,77,0.2)' : 'rgba(0,224,255,0.2)'}" />`;
                svg += `<circle r="24" fill="var(--bg-card)" stroke="${color}" stroke-width="2" />`;
                svg += `<text text-anchor="middle" dominant-baseline="central" fill="${color}" font-family="var(--font-mono)" font-weight="bold" font-size="14">${node.label}</text>`;
                svg += `</g>`;
            });
           
            svg += '</svg>';
            return svg;
        }

        function renderResolution() {
            if (!resolutionResult || resolutionResult.recommendations.length === 0) {
                if (detectionResult && detectionResult.isSafe && !detectionResult.isDeadlocked) {
                    document.getElementById('resolutionResults').innerHTML = `
                        <div class="text-center" style="padding:3rem;">
                            <div style="font-size:4rem;margin-bottom:1rem;">‚úì</div>
                            <h3 style="color:var(--neon-green);">System is Healthy</h3>
                            <p style="color:var(--text-muted);">No resolution needed. The system is in a safe state.</p>
                        </div>
                    `;
                } else {
                    document.getElementById('resolutionResults').innerHTML = '<div class="text-center" style="padding:3rem;color:var(--text-muted);">Click "Generate Suggestions" to get recommendations</div>';
                }
                return;
            }
           
            const { recommendations, best } = resolutionResult;
           
            const methodIcons = {
                'rollback': '‚Ü©',
                'preempt': '‚ö°',
                'priority-boost': '‚¨Ü',
                'throttle': '‚è∏',
                'kill': '‚úï'
            };
           
            const impactColors = {
                'Low': 'var(--neon-green)',
                'Medium': 'var(--neon-amber)',
                'High': 'var(--neon-red)'
            };
           
            let html = `
                ${best ? `
                    <div class="card mb-3" style="border-color:var(--neon-green);">
                        <div class="flex items-center gap-2 mb-2">
                            <span style="color:var(--neon-green);font-size:1.5rem;">‚òÖ</span>
                            <h3 style="color:var(--neon-green);">Recommended Action</h3>
                        </div>
                        <p><strong>${methodIcons[best.method]} ${best.method.toUpperCase()}</strong> ${best.targetProcess >= 0 ? `(P${best.targetProcess})` : ''}</p>
                        <p style="color:var(--text-secondary);">${best.explanation}</p>
                        <button class="btn btn-success mt-2" onclick="applyRecommendation(0)">Apply This Resolution</button>
                    </div>
                ` : ''}
               
                <h3 class="mb-2">All Recommendations</h3>
                ${recommendations.map((r, i) => `
                    <div class="recommendation">
                        <div class="recommendation-header">
                            <span class="recommendation-method" style="color:${impactColors[r.impact]};">
                                ${methodIcons[r.method]} ${r.method.replace('-', ' ')}
                            </span>
                            <span class="badge" style="color:${impactColors[r.impact]};border:1px solid ${impactColors[r.impact]};">
                                ${r.impact} Impact
                            </span>
                        </div>
                        <p>${r.explanation}</p>
                        <div class="flex gap-2 mt-2" style="font-size:0.85rem;color:var(--text-muted);">
                            <span>Cost: ${r.estimatedCost}</span>
                            <span>‚Ä¢</span>
                            <span>Work Lost: ${r.workLost}</span>
                            <span>‚Ä¢</span>
                            <span>Affected: ${r.processesAffected} process(es)</span>
                        </div>
                        <button class="btn btn-secondary mt-2" onclick="applyRecommendation(${i})">Apply</button>
                    </div>
                `).join('')}
               
                <div class="flex gap-2 mt-3">
                    <button class="btn btn-secondary" onclick="exportReport()">üìÑ Export Report</button>
                </div>
            `;
           
            document.getElementById('resolutionResults').innerHTML = html;
        }

        function applyRecommendation(index) {
            const resolution = resolutionResult.recommendations[index];
            systemState = applyResolution(systemState, resolution);
           
            // Re-run analysis
            renderMatrices();
            runPrediction();
            runDetection();
            runResolution();
           
            alert(`Applied: ${resolution.method.toUpperCase()} on P${resolution.targetProcess >= 0 ? resolution.targetProcess : 'all'}`);
        }

        function exportReport() {
            const report = {
                timestamp: new Date().toISOString(),
                systemState: systemState,
                prediction: predictionResult,
                detection: detectionResult,
                resolution: resolutionResult
            };
           
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `deadlock-report-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // =============================================
        // INITIALIZATION
        // =============================================
        document.addEventListener('DOMContentLoaded', () => {
            renderMatrices();
        });
    </script>
</body>
</html>
